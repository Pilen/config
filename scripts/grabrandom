#!/usr/bin/env python3
import argparse
import random
import sys
from pathlib import Path
from typing import List, Set

def fixseed(input: List[str]):
    random.seed("\n".join(input))

def get_paths(input: List[str]):
    result = []
    for raw in input:
        p = Path(raw)
        if not p.is_file():
            print("ERROR not a file: {}".format(p), file=sys.stderr)
            sys.exit(1)
        result.append(p)
    return result

def total_line_count(paths: List[Path]):
    lines = 0
    for path in paths:
        with path.open() as f:
            for line in f:
                lines += 1
    return lines

def select_lines(amount:int , line_count:int, include:Set[int]):
    amount += len(include)
    selected = set()
    selected.update(include)
    while len(selected) < amount:
        x = random.randint(1, line_count)
        selected.add(x)
    return selected

def get_next(it):
    try:
        return next(it)
    except StopIteration as e:
        return None

def grab_selected(paths:List[Path], selected:Set[int]):
    selected = iter(sorted(selected))
    n = get_next(selected)
    line_no = 0
    for path in paths:
        with path.open() as f:
            for line in f:
                line_no += 1
                if line_no == n:
                    yield line
                    n = get_next(selected)
                    if n is None:
                        return
    print("ERROR: Ran out of lines, did the files change?", file=sys.stderr)
    sys.exit(1)

def print_selected(lines):
    for line in lines:
        print(line, end="")

def analyze(selected, lines):
    selected = sorted(selected)
    previous = selected[0]
    diffs = []
    print(previous, "-")
    for item in selected[1:]:
        diff = item - previous
        print(item, diff)
        diffs.append(diff)
        previous = item
    import statistics
    mean = statistics.mean(diffs)
    stdev = statistics.pstdev(diffs)
    print("mean:", mean)
    print("stdev:", stdev)
    print("expected", lines/len(selected))



# USE THIS:
# Reservoir sampling
# def grab_random(it, k):
#     it = iter(it)
#     selected = []
#     for i, x in enumerate(it):
#         if i < k:
#             selected.append((i, x))
#         else:
#             j = random.randint(0, i)
#             if j < k:
#                 selected[j] = (i, x)
#     selected.sort()
#     return [x for i, x in selected]
# grab_random(['a', 'b', 'c', 'd', 'e'], 2)

# def analyze(it, k, r):
#     c = collections.Counter()
#     for i in range(r):
#         for x in grab_random(it, k):
#             c[x] += 1
#     return c.most_common()

def analyze2(p, k, r):
    import collections
    c = collections.Counter()
    for i in range(r):
        for x in grab_lines(p, k, []):
            c[x] += 1
    return c.most_common()

def grab_lines(paths, amount, include):
    a = -1
    i = -1
    include = sorted(include)
    fixed = []
    selected = []
    for path in paths:
        include_it = iter(include)
        next_include = next(include_it, None)
        with path.open() as f:
            for r, line in enumerate(f, 1):
                a += 1
                if r == next_include:
                    next_include = next(include_it, None)
                    fixed.append((i, line))
                    continue
                i += 1
                if i < amount:
                    selected.append((i, line))
                else:
                    j = random.randint(0, a)
                    if j < amount:
                        selected[j] = (i, line)
    selected.extend(fixed)
    selected.sort()
    return (x for i, x in selected)

def grab_lines(paths, amount, include):
    a = -1
    i = -1
    include = iter(sorted(include))
    fixed = []
    selected = []
    for path in paths:
        next_include = next(include, None)
        with path.open() as f:
            for r, line in enumerate(f, 1):
                a += 1
                if r == next_include:
                    next_include = next(include, None)
                    fixed.append((i, line))
                    continue
                i += 1
                if i < amount:
                    selected.append((i, line))
                else:
                    j = random.randint(0, a)
                    if j < amount:
                        selected[j] = (i, line)
    selected.extend(fixed)
    selected.sort()
    return (x for i, x in selected)

def main():
    parser = argparse.ArgumentParser()
    # parser.add_argument("input", nargs="*", type=argparse.FileType("r"), default=sys.stdin, help="The files to select from")
    parser.add_argument("input", nargs="*", help="The files to select from") # Needs to be filenames, as they are read twice!
    parser.add_argument("-n", "--amount", required=True, type=int, help="The amount of random rows to grab")
    parser.add_argument("-i", "--include", default=[], nargs="*", type=int, help="A specific line to add to the output in addition to the output")
    parser.add_argument("-d", "--deterministic", action="store_true", help="Grab a pseudo random but deterministic set of lines, based(seeded) on the filenames")
    args = parser.parse_args()

    if args.deterministic:
        fixseed(args.input)
    paths = get_paths(args.input)
    # line_count = total_line_count(paths)
    # selected = select_lines(args.amount, line_count, set(args.include))
    # it = grab_selected(paths, selected)
    it = grab_lines(paths, args.amount, set(args.include))
    print_selected(it)
    # analyze(selected, line_count)
if __name__ == "__main__":
    main()
