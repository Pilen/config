#!/usr/bin/env python3

"""
Wrapper around sshfs, so it be used either way

# https://blog.dhampir.no/content/reverse-sshfs-mounts-fs-push

If you get the following message when reversing:
bash: sshfs: command not found
Then you must install sshfs on remote system

If you get the following message when reversing:
fuse: bad mount point `/opt/aimdev': No such file or directory
Then you must make the dir /opt/aimdev on the remote
"""

import argparse
import inspect
import json
import re
import subprocess
import time
from pathlib import Path

PROCESS = None

class UserError(Exception):
    pass

class Location:
    def __init__(self, location):
        match = re.fullmatch("((([^@/]+)@)?([^:/]+):)?(.+)", location)
        if not match:
            raise UserError("Not a valid location: {}".format(location))
        self.location = location
        self.user = match.group(3)
        self.host = match.group(4)
        self.dir = match.group(5)
        if self.is_remote and self.dir[0] != "/":
            self.dir = str(Path(self.dir).absolute())

    @property
    def user_host(self):
        if self.user:
            return "{}@{}".format(self.user, self.host)
        else:
            return self.host

    @property
    def is_remote(self):
        return self.host is not None


def sshfs(source, destination):
    assert not destination.is_remote
    if destination.is_remote:
        raise UserError("Destination should not be remote: {}".format(destination.location))
    # -f foreground operation
    process = subprocess.Popen(["sshfs", source.location, destination.location, "-f",
                                "-o", "cache=yes",
                                "-o", "kernel_cache",
                                "-o", "compression=yes"])
    return process


def reverse_sshfs(source, destination, should_sudo):
    assert not source.is_remote
    if source.is_remote:
        raise UserError("Source should not be remote: {}".format(destination.location))
    # sudo = ["sudo"] if not destination.user == "root" else []
    sudo = ["sudo"] if should_sudo else []
    command = ["dpipe", "/usr/lib/openssh/sftp-server", "=",
               "ssh", "-o", "LogLevel=error", destination.user_host, *sudo, "sshfs", ":"+source.dir, destination.dir,
               "-o", "slave",
               "-o", "idmap=user",
               "-o", "gid=0",
               # "-o", "transform_symlinks",
               # "-o", "follow_symlinks",
    ]
    print(command)
    process = subprocess.Popen(command)
    return process


def reanimate(destination, should_sudo):
    # THIS IS BLODDY STUPID!:
    # ONLY refresh the host this script is actually connected to,
    # Or at least make it a function, then we could have have a flag to refresh evyrthing connected, but what would we gain?
    # # get output of subprocess.Popen(["psgrep", "--list-full", "-full", "sshfs"])
    # # incomming:
    # # TODO: do some other match
    # # outgoing:
    # re.match("ssh ([^ ]+) (sudo )?sshfs")

    # We might want to do (at least some of) the work in a script in remoteconfig/ that takes a session name and a path as arguments and refreshes the tmux sessions
    # So, remote-files does not technically know about remoteconfig. And we do not want to store an external script, and we do not want to embed python code in a string.
    # So we could use def foo(): ... and then inspect.getsource(foo) to get the code and then create a "script" with that concatenated with a call and then run that "script" via ssh host python3 -c ...

    # for each outgoing connection
    # """findmnt --noheadings -t fuse.sshfs"""
    # for each tmux pane where the pane_current_path is (or is a child) of a mount
    # if pane_current_command != bash: show warning
    # else
    # """tmux send-keys -t "spi:0.0" C-u 'cd "$(pwd)"' Enter C-y"""
    # C-u clears the input
    """
    tmux display-message -p -F "#{session_name}"

    $2 is the id (unique) of a session, could be session number 0. Most likely it is easier to use the session name rather than escaping.
    @2 is the id (unique) of a window, could be window number 0 of a session
    %2 is the id (unique) of a pane, could be pane number 0 of a window

    # if sessionname is spi:
    tmux list-sessions -F "#{session_name}"
    tmux list-windows -t spi -F "#{session_name} #{window_id} #{window_name}"
    tmux list-panes -t "other:0" -F "#{pane_id}"
    tmux list-panes -t "other:@2" -F "#{pane_id}"

    tmux display-message -p -F "#{pane_current_path}"
    tmux display-message -p -F "#{pane_current_command}"



    tmux list-panes -a -F "#{session_id}:#{window_id}:#{pane_id} #{pane_current_command} #{pane_current_path}"
    $2:@2:%2 sleep /root/.config
    $0:@0:%0 bash  /
    pane_current_* is actaully the current thing! Yes
    """

    print("Reanimating", destination.user_host, should_sudo)
    path = "/"
    source = inspect.getsource(reanimate_magic) + "reanimate_magic({})".format(json.dumps(destination.dir))
    # sudo = ["sudo"] if not destination.user == "root" else []
    sudo = ["sudo"] if should_sudo else []
    p = subprocess.Popen([
        "ssh",
        "-o", "LogLevel=error",
        destination.user_host,
        *sudo,
        "python3", "-c", "'{}'".format(source)])
    p.wait()


def reanimate_magic(root):
    import subprocess
    import re
    # tmux list-panes -a -F "#{session_id}:#{window_id}:#{pane_id} #{pane_current_command} #{pane_start_command} #{pane_current_path}"
    command = ["tmux", "list-panes", "-a", "-F", "#{session_id}:#{window_id}:#{pane_id} #{pane_current_command} #{pane_current_path}"]
    output = subprocess.check_output(command, universal_newlines=True).split("\n")
    print(output)
    for line in output:
        if not line:
            continue
        match = re.fullmatch("(\\$[0-9]+):(@[0-9]+):(%[0-9]+) ([^ ]+) (.*)", line)
        session_id, window_id, pane_id, command, path = match.groups()
        if command == "bash":
            # Unfortunately the pane_current_path will be set to / if the mount point disappears :(
            if path.startswith(root) or path == "/":
                # C-y yanks what C-u killed, but if there were no text C-u wont put anything in the killring so C-y will yank something old
                t = subprocess.check_output(["tmux", "send-keys", "-t", pane_id, "C-u", " cd \"$(pwd)\"", "Enter"]) # The space in front of `cd` causes the command to not be recorded in history in some shells



def monitor_suspended(process, duration, threshold):
    while True:
        before = time.monotonic()
        try:
            process.wait(duration)
            print("Process quit", process.returncode)
            return False
        except subprocess.TimeoutExpired:
            pass
        after = time.monotonic()
        difference = after - before
        if difference > threshold:
            return True
    # while true
    # Capture time
    # sleep duration,
    # if current time is much greater than captured time + duration:
    # the system has been suspended, so reconnect sshfs and
    #
    # and by sleep I mean, process.wait(duration)
    # so dont wait in function call as now


def main():
    parser = argparse.ArgumentParser()
    # parser.add_argument("--source", "-s", help="The filesystem where the files are located, can be remote")
    # parser.add_argument("--destination", "-d", help="Where to mount the filesystem, can be remote if FROM isn't")
    parser.add_argument("source", help="The filesystem where the files are located, can be remote")
    parser.add_argument("destination", help="Where to mount the filesystem, can be remote if FROM isn't")
    parser.add_argument("--reanimate", action="store_true")
    parser.add_argument("--sudo", action="store_true")
    args = parser.parse_args()

    source = Location(args.source)
    destination = Location(args.destination)

    if source.is_remote and destination.is_remote:
        print("Error! Both source and destination are remote")
        return
    if not source.is_remote and not destination.is_remote:
        print("Error! Both source and destination are local")
        return
    if args.reanimate:
        reanimate(destination, args.sudo)
        return

    process = None
    try:
        while True:
            if source.is_remote:
                process = sshfs(source, destination)
            else:
                process = reverse_sshfs(source, destination, args.sudo)
                time.sleep(1)
                reanimate(destination, args.sudo)
                while monitor_suspended(process, 240, 240*2):
                    reanimate(destination, args.sudo)

    except UserError as e:
        print("Error! {}".format(e))
    except KeyboardInterrupt as e:
        print()
    finally:
        if process is not None:
            if process.returncode is None:
                process.terminate()


if __name__ == "__main__":
    main()
